// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var Js_list = require("rescript/lib/js/js_list.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var Belt_MapString = require("rescript/lib/js/belt_MapString.js");
var Reducer_BuiltIn = require("./Reducer_BuiltIn.bs.js");
var Reducer_ListExt = require("./Reducer_ListExt.bs.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");
var Reducer_MathJsParse = require("./Reducer_MathJsParse.bs.js");
var ReducerExternal_LispValue = require("../ReducerExternal/ReducerExternal_LispValue.bs.js");

function fromNode(_node) {
  while(true) {
    var node = _node;
    var aNodeType = node.type;
    switch (aNodeType) {
      case "ConstantNode" :
          var x = Reducer_MathJsParse.constantNodeValue(node);
          if (typeof x === "number") {
            return {
                    TAG: /* Error */1,
                    _0: "Unhandled MathJs constantNode value"
                  };
          }
          switch (x.TAG | 0) {
            case /* ExnNumber */0 :
                return {
                        TAG: /* Ok */0,
                        _0: {
                          TAG: /* LcValue */1,
                          _0: {
                            TAG: /* LvNumber */1,
                            _0: x._0
                          }
                        }
                      };
            case /* ExnString */1 :
                return {
                        TAG: /* Ok */0,
                        _0: {
                          TAG: /* LcValue */1,
                          _0: {
                            TAG: /* LvString */2,
                            _0: x._0
                          }
                        }
                      };
            case /* ExnBool */2 :
                return {
                        TAG: /* Ok */0,
                        _0: {
                          TAG: /* LcValue */1,
                          _0: {
                            TAG: /* LvBool */0,
                            _0: x._0
                          }
                        }
                      };
            
          }
      case "FunctionNode" :
          var lispName = {
            TAG: /* LcSymbol */2,
            _0: node.fn
          };
          var lispArgs = fromNodeList(Belt_List.fromArray(node.args));
          return Belt_Result.map(lispArgs, (function(lispName){
                    return function (aList) {
                      return {
                              TAG: /* LcList */0,
                              _0: {
                                hd: lispName,
                                tl: aList
                              }
                            };
                    }
                    }(lispName)));
      case "OperatorNode" :
          var lispName$1 = {
            TAG: /* LcSymbol */2,
            _0: node.fn
          };
          var lispArgs$1 = fromNodeList(Belt_List.fromArray(node.args));
          return Belt_Result.map(lispArgs$1, (function(lispName$1){
                    return function (aList) {
                      return {
                              TAG: /* LcList */0,
                              _0: {
                                hd: lispName$1,
                                tl: aList
                              }
                            };
                    }
                    }(lispName$1)));
      case "ParenthesisNode" :
          _node = node.content;
          continue ;
      default:
        return {
                TAG: /* Error */1,
                _0: "TODO MathJs Node Type: " + aNodeType
              };
    }
  };
}

function fromNodeList(nodeList) {
  return Belt_Result.map(Belt_List.reduce(nodeList, {
                  TAG: /* Ok */0,
                  _0: /* [] */0
                }, (function (racc, currNode) {
                    return Belt_Result.flatMap(racc, (function (acc) {
                                  return Belt_Result.map(fromNode(currNode), (function (newCode) {
                                                return {
                                                        hd: newCode,
                                                        tl: acc
                                                      };
                                              }));
                                }));
                  })), Belt_List.reverse);
}

function show(lispCode) {
  switch (lispCode.TAG | 0) {
    case /* LcList */0 :
        return "(" + Caml_splice_call.spliceObjApply("", "concat", [Belt_List.toArray(Reducer_ListExt.interperse(Belt_List.map(lispCode._0, show), " "))]) + ")";
    case /* LcValue */1 :
        return ReducerExternal_LispValue.show(lispCode._0);
    case /* LcSymbol */2 :
        return ":" + lispCode._0;
    
  }
}

function showResult(codeResult) {
  if (codeResult.TAG === /* Ok */0) {
    return "Ok(" + show(codeResult._0) + ")";
  } else {
    return "Error(" + String(codeResult._0) + ")";
  }
}

function parse(mathJsCode) {
  return Belt_Result.flatMap(Reducer_MathJsParse.parse(mathJsCode), fromNode);
}

var defaultBindings = Belt_MapString.fromArray([]);

function execFunctionCall(lisp, _bindings) {
  var stripArgs = function (args) {
    return Belt_List.map(args, (function (a) {
                  switch (a.TAG | 0) {
                    case /* LcValue */1 :
                        return a._0;
                    case /* LcList */0 :
                    case /* LcSymbol */2 :
                        return /* LvUndefined */0;
                    
                  }
                }));
  };
  if (Js_list.isEmpty(lisp)) {
    return {
            TAG: /* Error */1,
            _0: "Function expected; got nothing"
          };
  }
  var fname = List.hd(lisp);
  switch (fname.TAG | 0) {
    case /* LcList */0 :
    case /* LcValue */1 :
        return {
                TAG: /* Error */1,
                _0: "TODO User space functions not yet allowed"
              };
    case /* LcSymbol */2 :
        var aCall_0 = fname._0;
        var aCall_1 = Belt_List.toArray(stripArgs(List.tl(lisp)));
        var aCall = [
          aCall_0,
          aCall_1
        ];
        return Belt_Result.map(Reducer_BuiltIn.dispatch(aCall), (function (aValue) {
                      return {
                              TAG: /* LcValue */1,
                              _0: aValue
                            };
                    }));
    
  }
}

function execLispCode(aLispCode, bindings) {
  switch (aLispCode.TAG | 0) {
    case /* LcList */0 :
        return execLispList(aLispCode._0, bindings);
    case /* LcValue */1 :
    case /* LcSymbol */2 :
        return {
                TAG: /* Ok */0,
                _0: aLispCode
              };
    
  }
}

function execLispList(list, bindings) {
  return Belt_Result.flatMap(Belt_Result.map(Belt_List.reduce(list, {
                      TAG: /* Ok */0,
                      _0: /* [] */0
                    }, (function (racc, currCode) {
                        return Belt_Result.flatMap(racc, (function (acc) {
                                      return Belt_Result.map(execLispCode(currCode, bindings), (function (newCode) {
                                                    return {
                                                            hd: newCode,
                                                            tl: acc
                                                          };
                                                  }));
                                    }));
                      })), Belt_List.reverse), (function (aList) {
                return execFunctionCall(aList, bindings);
              }));
}

function evalWBindingsLispCode(aLispCode, bindings) {
  return Belt_Result.flatMap(execLispCode(aLispCode, bindings), (function (aCode) {
                switch (aCode.TAG | 0) {
                  case /* LcValue */1 :
                      return {
                              TAG: /* Ok */0,
                              _0: aCode._0
                            };
                  case /* LcList */0 :
                  case /* LcSymbol */2 :
                      return {
                              TAG: /* Error */1,
                              _0: "Unexecuted code remaining: " + show(aCode)
                            };
                  
                }
              }));
}

function evalWBindings(codeText, bindings) {
  return Belt_Result.flatMap(parse(codeText), (function (code) {
                return evalWBindingsLispCode(code, bindings);
              }));
}

function $$eval(code) {
  return evalWBindings(code, defaultBindings);
}

var LV;

var BuiltIn;

var RLE;

var Dbg;

var Result;

var MJ;

var MapString;

exports.LV = LV;
exports.BuiltIn = BuiltIn;
exports.RLE = RLE;
exports.Dbg = Dbg;
exports.Result = Result;
exports.MJ = MJ;
exports.fromNode = fromNode;
exports.fromNodeList = fromNodeList;
exports.show = show;
exports.showResult = showResult;
exports.parse = parse;
exports.MapString = MapString;
exports.defaultBindings = defaultBindings;
exports.execFunctionCall = execFunctionCall;
exports.execLispCode = execLispCode;
exports.execLispList = execLispList;
exports.evalWBindingsLispCode = evalWBindingsLispCode;
exports.evalWBindings = evalWBindings;
exports.$$eval = $$eval;
/* defaultBindings Not a pure module */
